<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Hashids.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.yatracker:hashids</a> &gt; <a href="index.source.html" class="el_package">com.yatracker</a> &gt; <span class="el_source">Hashids.java</span></div><h1>Hashids.java</h1><pre class="source lang-java linenums">package com.yatracker;

import com.yatracker.unicode.CharUnicode;
import com.yatracker.unicode.DualCharUnicode;
import com.yatracker.unicode.Unicode;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * @author ya
 */
<span class="fc" id="L19">@RequiredArgsConstructor(access = AccessLevel.PROTECTED)</span>
public final class Hashids {

    private static final long MODULO_PART = 100L;

    private static final int SPLIT_AT_EVERY_NTH = 12;

    private final HashidsUnicodeTable table;

    private static int calcNumberIdInt(Number ...numbers) {
<span class="fc" id="L29">        int numbersIdInt = 0;</span>
<span class="fc" id="L30">        int numberLength = numbers.length;</span>
<span class="fc bfc" id="L31" title="All 2 branches covered.">        for (int i = 0; i &lt; numberLength; i++) {</span>
<span class="fc" id="L32">            Number numberLike = numbers[i];</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">            if (numberLike instanceof BigInteger) {</span>
<span class="fc" id="L34">                BigInteger number = (BigInteger) numberLike;</span>
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">                if (number.compareTo(BigInteger.ZERO) &lt; 0) {</span>
<span class="nc" id="L36">                    throw new HashidsException(String.format(&quot;Negative number (%s) when encoding is not supported&quot;, number));</span>
                }
<span class="fc" id="L38">                numbersIdInt += ((BigInteger) numberLike).mod(BigInteger.valueOf(i + MODULO_PART)).longValue();</span>
<span class="fc" id="L39">            } else {</span>
<span class="fc" id="L40">                long number = numberLike.longValue();</span>
<span class="fc bfc" id="L41" title="All 2 branches covered.">                if (number &lt; 0) {</span>
<span class="fc" id="L42">                    throw new HashidsException(String.format(&quot;Negative number (%s) when encoding is not supported&quot;, number));</span>
                }
<span class="fc" id="L44">                numbersIdInt += (number % (i + MODULO_PART));</span>
            }
        }

<span class="fc" id="L48">        return numbersIdInt;</span>
    }

    private static int calcExtraNumber(Number numberLike, int charCode) {
<span class="fc bfc" id="L52" title="All 2 branches covered.">        if (numberLike instanceof BigInteger) {</span>
<span class="fc" id="L53">            return ((BigInteger) numberLike).mod(BigInteger.valueOf(charCode)).intValue();</span>
        }
<span class="fc" id="L55">        return (int) (numberLike.longValue() % charCode);</span>
    }

    public String encode(Number ...numbers) {
<span class="fc bfc" id="L59" title="All 4 branches covered.">        if (Objects.isNull(numbers) || numbers.length == 0) {</span>
<span class="fc" id="L60">            return HashidsUnicodeTable.EMPTY_STRING;</span>
        }

<span class="fc" id="L63">        Unicode[] alphabet = table.alphabet;</span>

<span class="fc" id="L65">        int alphabetLength = alphabet.length;</span>
<span class="fc" id="L66">        int numbersIdInt = calcNumberIdInt(numbers);</span>

<span class="fc" id="L68">        UnicodeArrayBuilder ret = new UnicodeArrayBuilder();</span>
<span class="fc" id="L69">        Unicode lottery = alphabet[numbersIdInt % alphabetLength];</span>
<span class="fc" id="L70">        ret.push(lottery);</span>

<span class="fc" id="L72">        Unicode[] seps = table.seps;</span>
<span class="fc" id="L73">        Unicode[] salt = table.salt;</span>

<span class="fc" id="L75">        int numberLength = numbers.length;</span>
<span class="fc" id="L76">        int sepsLength = seps.length;</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        for (int i = 0; i &lt; numberLength; i++) {</span>
<span class="fc" id="L78">            Number number = numbers[i];</span>
<span class="fc" id="L79">            Unicode[] buffer = UnicodeArrayUtil.push(lottery, salt, alphabet);</span>
<span class="fc" id="L80">            alphabet = UnicodeArrayUtil.shuffle(alphabet, buffer);</span>

<span class="fc" id="L82">            Unicode[] last = toAlphabet(number, alphabet);</span>
<span class="fc" id="L83">            ret.push(last);</span>

<span class="fc bfc" id="L85" title="All 2 branches covered.">            if (i &lt; numberLength - 1) {</span>
<span class="fc" id="L86">                int charCode = last[0].codePoint() + i;</span>
<span class="fc" id="L87">                int extraNumber = calcExtraNumber(number, charCode);</span>
<span class="fc" id="L88">                ret.push(seps[extraNumber % sepsLength]);</span>
            }
        }

<span class="fc" id="L92">        int minLength = table.minLength;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (ret.size() &lt; minLength) {</span>
<span class="fc" id="L94">            Unicode[] guards = table.guards;</span>
<span class="fc" id="L95">            int guardsLength = guards.length;</span>
<span class="fc" id="L96">            int prefixGuardIndex = (numbersIdInt + ret.alphabetAt(0).codePoint()) % guardsLength;</span>
<span class="fc" id="L97">            ret.unshift(guards[prefixGuardIndex]);</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">            if (ret.size() &lt; minLength) {</span>
<span class="fc" id="L100">                int suffixGuardIndex = (numbersIdInt + ret.alphabetAt(2).codePoint()) % guardsLength;</span>
<span class="fc" id="L101">                ret.push(guards[suffixGuardIndex]);</span>
            }
        }

<span class="fc" id="L105">        int halfLength = alphabetLength / 2;</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        while (ret.size() &lt; minLength) {</span>
<span class="fc" id="L107">            alphabet = UnicodeArrayUtil.shuffle(alphabet, alphabet);</span>
<span class="fc" id="L108">            ret.unshift(UnicodeArrayUtil.slice(alphabet, halfLength));</span>
<span class="fc" id="L109">            ret.push(UnicodeArrayUtil.slice(alphabet, 0, halfLength));</span>

<span class="fc" id="L111">            int excess = ret.size() - minLength;</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if (excess &gt; 0) {</span>
<span class="fc" id="L113">                int halfOfExcess = excess / 2;</span>
<span class="fc" id="L114">                ret = ret.slice(halfOfExcess, halfOfExcess + minLength);</span>
            }
<span class="fc" id="L116">        }</span>

<span class="fc" id="L118">        return ret.toString();</span>
    }

    public Number[] decode(String id) {
<span class="fc bfc" id="L122" title="All 4 branches covered.">        if (Objects.isNull(id) || id.isEmpty()) {</span>
<span class="fc" id="L123">            return HashidsUnicodeTable.EMPTY_NUMBER_ARRAY;</span>
        }

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (!table.allowedCharsRegExp.matcher(id).matches()) {</span>
<span class="fc" id="L127">            throw new HashidsException(String.format(&quot;The provided ID (%s) is invalid, as it contains characters that do not match the alphabet table&quot;, id));</span>
        }

<span class="fc" id="L130">        String[] idGuardsArray = table.guardsRegExp.split(id);</span>
<span class="fc bfc" id="L131" title="All 4 branches covered.">        int splitIndex = idGuardsArray.length == 3 || idGuardsArray.length == 2 ? 1 : 0;</span>

<span class="fc" id="L133">        String idBreakdown = idGuardsArray[splitIndex];</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (idBreakdown.isEmpty()) {</span>
<span class="nc" id="L135">            return HashidsUnicodeTable.EMPTY_NUMBER_ARRAY;</span>
        }

<span class="fc" id="L138">        int lotteryCodePoint = idBreakdown.codePointAt(0);</span>
        Unicode lottery;
        int lotteryNextCharIndex;
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (Character.isSupplementaryCodePoint(lotteryCodePoint)) {</span>
<span class="fc" id="L142">            lottery = new DualCharUnicode(Character.toChars(lotteryCodePoint));</span>
<span class="fc" id="L143">            lotteryNextCharIndex = 2;</span>
        } else {
<span class="fc" id="L145">            lottery = new CharUnicode((char) lotteryCodePoint);</span>
<span class="fc" id="L146">            lotteryNextCharIndex = 1;</span>
        }

<span class="fc" id="L149">        String idSubString = idBreakdown.substring(lotteryNextCharIndex);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (idSubString.isEmpty()) {</span>
<span class="fc" id="L151">            return HashidsUnicodeTable.EMPTY_NUMBER_ARRAY;</span>
        }
<span class="fc" id="L153">        String[] ids = table.sepsRegExp.split(idSubString);</span>
<span class="fc" id="L154">        List&lt;Unicode[]&gt; idArray = UnicodeArrayUtil.from(ids);</span>

<span class="fc" id="L156">        Unicode[] alphabet = table.alphabet;</span>
<span class="fc" id="L157">        Number[] result = new Number[idArray.size()];</span>

<span class="fc" id="L159">        Unicode[] salt = table.salt;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (int i = 0; i &lt; idArray.size(); i++) {</span>
<span class="fc" id="L161">            Unicode[] subId = idArray.get(i);</span>
<span class="fc" id="L162">            Unicode[] buffer = UnicodeArrayUtil.push(lottery, salt, alphabet);</span>
<span class="fc" id="L163">            alphabet = UnicodeArrayUtil.shuffle(alphabet, buffer);</span>
<span class="fc" id="L164">            result[i] = fromAlphabet(subId, alphabet);</span>
        }

        // if the result is different from what we'd expect, we return an empty result (malformed input):
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (!Objects.equals(id, encode(result))) {</span>
<span class="nc" id="L169">            return HashidsUnicodeTable.EMPTY_NUMBER_ARRAY;</span>
        }
<span class="fc" id="L171">        return result;</span>
    }

    public String encodeHex(String inputHex) {
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">        if (Objects.isNull(inputHex) || !HashidsUnicodeTable.HEX_PATTERN.matcher(inputHex).matches()) {</span>
<span class="fc" id="L176">            return HashidsUnicodeTable.EMPTY_STRING;</span>
        }

<span class="fc" id="L179">        Number[] numbers = splitAtIntervalAndMap(inputHex);</span>
<span class="fc" id="L180">        return this.encode(numbers);</span>
    }

    public String decodeHex(String id) {
<span class="fc" id="L184">        Number[] numbers = this.decode(id);</span>
<span class="fc" id="L185">        return Arrays.stream(numbers)</span>
                // the decoded number here is always long type.
<span class="fc" id="L187">                .map(number -&gt; Long.toString(number.longValue(), 16).substring(1))</span>
<span class="fc" id="L188">                .collect(Collectors.joining());</span>
    }

    private static Number[] splitAtIntervalAndMap(String str) {
<span class="fc" id="L192">        int strLength = str.length();</span>
<span class="fc" id="L193">        int size = (int) Math.ceil((double) strLength / SPLIT_AT_EVERY_NTH);</span>
<span class="fc" id="L194">        Number[] numbers = new Number[size];</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L196">            int start = i * SPLIT_AT_EVERY_NTH;</span>
<span class="fc" id="L197">            int end = Math.min(start + SPLIT_AT_EVERY_NTH, strLength);</span>
<span class="fc" id="L198">            String s = str.substring(start, end);</span>
<span class="fc" id="L199">            numbers[i] = Long.parseLong(&quot;1&quot; + s, 16);</span>
        }
<span class="fc" id="L201">        return numbers;</span>
    }

    private static Unicode[] toAlphabet(Number numberLike, Unicode[] alphabet) {
<span class="fc" id="L205">        List&lt;Unicode&gt; array = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (numberLike instanceof BigInteger) {</span>
<span class="fc" id="L207">            BigInteger number = (BigInteger) numberLike;</span>
<span class="fc" id="L208">            BigInteger alphabetLength = BigInteger.valueOf(alphabet.length);</span>
            do {
<span class="fc" id="L210">                array.add(alphabet[number.mod(alphabetLength).intValue()]);</span>
<span class="fc" id="L211">                number = number.divide(alphabetLength);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            } while (number.compareTo(BigInteger.ZERO) &gt; 0);</span>
<span class="fc" id="L213">        } else {</span>
<span class="fc" id="L214">            int alphabetLength = alphabet.length;</span>
<span class="fc" id="L215">            long number = numberLike.longValue();</span>
            do {
<span class="fc" id="L217">                array.add(alphabet[(int) (number % alphabetLength)]);</span>
<span class="fc" id="L218">                number = number / alphabetLength;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            } while (number &gt; 0);</span>
        }

<span class="fc" id="L222">        return UnicodeArrayUtil.reverse(array);</span>
    }

    private static Number fromAlphabet(Unicode[] inputChars, Unicode[] alphabetChars) {
<span class="fc" id="L226">        long carry = 0L;</span>
<span class="fc" id="L227">        BigInteger bigIntCarry = null;</span>

<span class="fc" id="L229">        int alphabetCharsLength = alphabetChars.length;</span>
<span class="fc" id="L230">        long safeLongCarry = (Long.MAX_VALUE / alphabetCharsLength) - 1;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        for (Unicode input : inputChars) {</span>
<span class="fc" id="L232">            int index = indexOf(alphabetChars, input);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            if (index == -1) {</span>
<span class="nc" id="L234">                throw new HashidsException(String.format(&quot;The provided ID (%s) is invalid, as it contains characters that do not exist in the alphabet&quot;, input));</span>
            }

<span class="fc bfc" id="L237" title="All 4 branches covered.">            if (Objects.isNull(bigIntCarry) &amp;&amp; carry &gt;= safeLongCarry) {</span>
<span class="fc" id="L238">                bigIntCarry = BigInteger.valueOf(carry);</span>
            }

<span class="fc bfc" id="L241" title="All 2 branches covered.">            if (Objects.nonNull(bigIntCarry)) {</span>
<span class="fc" id="L242">                bigIntCarry = bigIntCarry.multiply(BigInteger.valueOf(alphabetCharsLength)).add(BigInteger.valueOf(index));</span>
            } else {
<span class="fc" id="L244">                carry = carry * alphabetCharsLength + index;</span>
            }
        }

<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (Objects.isNull(bigIntCarry)) {</span>
<span class="fc" id="L249">            return carry;</span>
        }

<span class="fc bfc" id="L252" title="All 2 branches covered.">        return bigIntCarry.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) &lt;= 0 ? bigIntCarry.longValue() : bigIntCarry;</span>
    }

    private static int indexOf(Unicode[] alphabets, Unicode alphabet) {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        for (int i = 0; i &lt; alphabets.length; i++) {</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (Objects.equals(alphabet, alphabets[i])) {</span>
<span class="fc" id="L258">                return i;</span>
            }
        }
<span class="nc" id="L261">        return -1;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>